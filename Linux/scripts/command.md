windows下打印目录树 

     tree /f

Linux 下目录 
tree --help
其中常用参数：
-a：打印全部文件。
-A：使用ASNI绘图字符显示树状图而非以ASCII字符组合（显示的树状图为实线不是虚线）
-C：在文件和目录清单加上色彩，便于区分各种类型。
-d：只打印目录。
-L level：指定打印目录的深度（层级）。
-f：打印出每个文件、目录的绝对路径。

---

删除行尾的^M：

    %s/\r//g


---

统计符合要求的字符串的长度

    awk -F': ' '/images/{print $2}' *.md | awk '{print length($0)}'


---

## 为啥要xargs?

通常linux命令可以用|首尾相连，上一个命令的 stdout 连接到下一个命令的 stdin。但是有些命令，比如ls、rm等，是从命令行参数接受输入的。这时候如果想把上一个命令的输出传给它们，就不好办了。所以就有了xargs。

简单而言，xargs可以把从 stdin 接受到的输入，用空白符分隔开，然后依次作为参数去调用xargs后面的命令。

## 用法

举个例子，想把所有.jpg文件删除，当然你可以rm *.jpg，但是如果要递归操作所有子目录下的文件呢？

可以这样：

    find . -name "*.jpg" | xargs rm

这样，所有被find找到的文件名，都会作为参数来调用rm命令了。

对于大多数情况，这一行命令没有问题，但是如有些文件名中包含空格，就会有问题了。**xargs默认以空白符分隔接受到的输入**，所以一个含有空格的文件名会被当做多个参数，分别传给rm。所以在处理文件名这类命令时，通常要这样：

    find . -name "*.jpg" -print0 | xargs -0 rm

**这里的`-print0`是告诉find命令，在每个输出后面以'\0'作为结束。-0是告诉xargs，使用'\0'来分隔输入，而不是空白符**。这样就避免出现问题了。

下面再考虑另一种情况，假设不是删除，而是想把符合要求的文件名都添加上后缀.bak怎么办？这时候需要这样：

    find . -name "*.jpg" -print0 | xargs -0 -I {} mv {} {}.bak

其中的-I {}是告诉xargs，后面的命令中，用{}表示占位符，将会被实际的参数替代。这样就行了。

其他有用的参数还有：   
-n 用于指定每次传递几个参数   
-d 用于指定切分输入内容时，具体的分隔符   
其他更多的参数，就参考man xargs吧。

---


awk /./ filename 删除文件的空行   