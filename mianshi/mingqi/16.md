## 2015小米暑期实习笔试题： 小米Git 

git是一种分布式代码管理工具，git通过树的形式记录文件的更改历史，比如： base'<–base<–A<–A’ ^ | — B<–B’ 小米工程师常常需要寻找两个分支最近的分割点，即base.假设git 树是多叉树，请实现一个算法，计算git树上任意两点的最近分割点。 （假设git树节点数为n,用邻接矩阵的形式表示git树：字符串数组matrix包含n个字符串，每个字符串由字符’0’或’1’组成，长度为n。matrix[i][j]==’1’当且仅当git树种第i个和第j个节点有连接。节点0为git树的根节点。）

**输入例子:**

> [01011,10100,01000,10000,10000],1,2

**输出例子:**

> 1


----

## 搜狗2016研发工程师编程题：矩阵元素相乘 


A[n,m]是一个n行m列的矩阵，a[i,j]表示A的第i行j列的元素，定义x[i,j]为A的第i行和第j列除了a[i,j]之外所有元素(共n+m-2个)的乘积，即x[i,j]=a[i,1]*a[i,2]*…*a[i,j-1]*…*a[i,m]*a[1,j]*a[2,j]…*a[i-1,j]*a[i+1,j]…*a[n,j],现输入非负整形的矩阵A[n,m]，求MAX(x[i,j])，即所有的x[i,j]中的最大值。

**输入描述:**

> 第一行两个整数n和m。之后n行输入矩阵，均为非负整数。

**输出描述:**

> 一行输出答案。

**输入例子:**

> 3 5  
> 5 1 8 5 2  
> 1 3 10 3 3  
> 7 8 5 5 16

**输出例子:**

> 358400



----

## 360研发工程师笔试编程题：挑选镇长 


360员工桂最近申请了一个长假，一个人背着包出去自助游了。  
路上，他经过了一个小镇，发现小镇的人们都围在一棵树下争吵。桂上前询问情况，得知小镇的人们正缺一个镇长，他们希望能选一个知名又公正的镇长，即，大家希望能选出一个人，所有人都认识他，但同时他不认识镇上除自己以外的其他人（在此，我们默认每个人自己认识自己）。可是小镇里的人太多了，一下子大家谁也说服不了谁。  
“这简单啊。”桂表示。于是他一下子统计出来了镇上人们相互之间的认识关系，并且一下子找到了合适的镇长人选。  
现在你手上也拿到了这样一份认识关系的清单。其中上面给出的认识关系是单向的，即，A认识B与B认识A是相互独立的，只给出A认识B就不能认为B认识A，例如，我认识你，你不一定认识我。而且，这里的认识关系也不具有传递性，即，A认识B，B认识C，但这不代表A认识C。同时，为了方便处理，这份清单中，镇上的N个人依次编号为1到N。你能否像桂一样快速找到合适的镇长人选呢？  
**输入描述:**

> 首先一个正整数T（T≤20），表示数据组数。  
> 之后每组数据的第一行有2个整数n 和m (1≤n≤105 ,0≤m≤3×105 )，依次表示镇上的人数和相互之间的认识关系数。  
> 之后m行，第 i 行每行两个数Ai和Bi (1≤Ai ,Bi ≤n )，表示Ai认识Bi。（保证没有重复的认识关系，但可能存在自己认识自己的认识关系）  
> 保证所有数据中80%的数据满足n≤1000,m≤10000

**输出描述:**

> 一共2T 行，每组数据对应2行。  
> 第一行，一个整数，表示你所找出来的合适的镇长人选人数num i 。  
> 第二行，num i 个整数，每两个数中间用空格隔开，表示你所选的合适的镇长的编号。  
> 特别的，如果并没有找到合适的镇长，第一行输出一个数0，第二行留空即可（参见样例）。

**输入例子:**

> 3  
> 2 0  
> 3 2  
> 1 2  
> 3 2  
> 4 5  
> 1 1  
> 2 1  
> 3 1  
> 4 1  
> 3 3

**输出例子:**

> 0

> 1  
> 2  
> 1  
> 1



----

## 4399游戏2015校园招聘笔试题：计算天数 


小陆每天要写一份工作日报，日报标准是“入职第X天-小陆-XXX”，对于“入职第几天”，小陆现在每次需要对上次写的日报标题里的天数+1， 遇到周末还要多加2天等等。请你写一段程序，帮小陆自动完成这件事，提供写日期当天的年月日，算出已入职的天数（假定小陆的入职时间是 2014年8月18日）。要求：不能使用时间，日期相关的库函数。



----


## 4399游戏2015校园招聘笔试题：哈夫曼树 

若以{4,5,6,7,8}作为叶子结点的权值构造哈夫曼树，则其带权路径长度是（）。

A. 24  
B. 30  
C. 53  
D. 69 ***

