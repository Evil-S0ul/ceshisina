## Mysql 四种 隔离级别学习

SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

### Read Uncommitted（读取未提交内容）

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少， **读取未提交的数据，也被称之为脏读（Dirty Read）。**

举个例子来说明一下 **脏读** , 如：在 `test` 库有一个表 `tx`，表里有3条数据，别外特别注意，测试之前先把自动提交事务关闭，并把隔离级别设置成`Read Committed`，如下图：

![23.png][0]

然后模拟 **客户端B**，也开启了一个事务；并更新一条操作，如：

    start transaction;
    update tx set num=10 where id=1;

重点开始看了，此时，客户端B并没有提交事务，而客户端A却能获取 B 更新的数据， 这就是 **脏读** ，效果如下:

![1462625229637737.png][1]


上节我们学习了[Read Uncommitted隔离级别][2]，在这种隔别级别下，可能会出现[脏读][2]，这一节，我们继续学习四种隔防级别中另一种 **Read Committed（读取提交内容）**。

### Read Committed（读取提交内容）

这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。**它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也会出现不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。**

举个例子来说明一下 **不可重复读**, 如：在 test 库有一个表 tx，表里有3条数据，别外特别注意，测试之前先把自动提交事务关闭，并把隔离级别设置成`Read Committed`，如下图：

![1.png][3]

这时客户端B也开启了一个事务，并更新数据，此时客户端A开始的事务并没有提交，并在这期间查询两次数据，发现数据并不一致，如下图

![2.png][4]

经过上面的实验可以得出结论，已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题，即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录，但不要求可重复读。


上节我们学习了[Read Committed][5]隔离级别，在这种隔别级别下，可能会出现[不可重复读][5]，这一节，我们继续学习四种隔防级别中另一种 **Repeatable Read（可重读）**。

### Repeatable Read（可重读）

**这是MySQL的默认事务隔离级别**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：`幻读 （Phantom Read）`。简单的说， **幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行** 。`InnoDB`和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

现在我们来举个例子说明一下 幻读，如：在test库里有一个表 tx， 表里有3条数据， **别外特别注意，测试之前先把自动提交事务关闭，并把隔离级别设置成Repeatable Read** ，如下图：

![1.png][6]

这时，客户端B也开启了一个事务，（ **特别说明：因为这里是测试，所以客户端B也要先设置好当前会话的隔离级别和关闭自动提交事务，要和客户端A保持一致** ），并更新了一条数据，并提交事务，如下图

![2.png][7]

特别注意：此时的客户A还没有提交事务，这时，客户A来查询数据会还是不变，如：

![3.png][8]

这种情况下，就不会像上一节，我们学的Read Committed（读取提交内容）级别下的，同一事务，不同时刻读到的数据不一致。我们再做一次插入数据，如下图：

![4.png][9]

客户端还是原来的数据。 **注意：客户端A在这时可能会出现新的数据，即客户端B新添加的数据，这就是会幻读** ；当客户端A提交事务后，就会得到新的数据。

由以上的实验可以得出结论，可重复读隔离级别只允许读取已提交记录，但是可能产生幻读问题(注意是可能，因为数据库对隔离级别的实现有所差别)，像以上 的实验，就没有出现数据幻读的问题。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。


上节我们学习了[Repeatable Read可重读][10]，在这种隔别级别下，可能会出现[幻读 （Phantom Read）][10]，但是InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题，这一节，我们继续学习四种隔防级别中另一种 **Serializable（可串行化**）。

### Serializable（可串行化）

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：

[脏读(Drity Read)][11]：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。

[不可重复读(Non-repeatable read)][12]:在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。

[幻读(Phantom Read)][10]:在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：

![f25d1672d12.jpeg][13]

现在我们来举个例子说明一下`Serializable`（可串行化）会出现的问题：

首页在客户端A我们把自动提交事务关闭，然后把隔离级别设置成 `Repeatable`，并开启了一个事务，如下图：

![QQ截图1.png][14]

这时，如果有客户端B也把自动提交事务关闭，然后把隔离级别设置成`Repeatable`（ **说明：我这里是测试，所以设置的当前会话的隔离，如果正式环境下，一般都是在配置文件里把Mysql的隔离级别设置好的。如果那样的话，客户端B就不要再设置级别了，因为默认就是和A一样的** ），然后也开启了一个事务，并插入一条数据，但是，我们发现，插入数据失败，如下图：

![QQ截图2.png][15]

通过上面测试我们知道，serializable完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止 。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。


[0]: ./img/1482208502596794.png
[1]: ./img/1482208502677752.png
[2]: http://www.yduba.com/biancheng-5971569393.html
[3]: ./img/1463808618112123.png
[4]: ./img/1463808629352732.png
[5]: http://www.yduba.com/biancheng-5911516590.html
[6]: ./img/1463803700541607.png
[7]: ./img/1463803714758519.png
[8]: ./img/1463803724267982.png
[9]: ./img/1463803732807137.png


[10]: http://www.yduba.com/biancheng-5811592809.html
[11]: http://www.yduba.com/biancheng-5971569393.html
[12]: http://www.yduba.com/biancheng-5911516590.html
[13]: ./img/1463798626775540.jpeg
[14]: ./img/1463798649983158.png
[15]: ./img/1463798668325084.png
