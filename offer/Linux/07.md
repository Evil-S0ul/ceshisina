# 十二条Linux运维面试必备经典笔试/面试题，来挑战一下吧！

 时间 2017-09-18 09:35:09 

原文[http://os.51cto.com/art/201709/551759.htm][1]



又到了一年一度的秋招，作为运维方向，看了一些面经，收集了一些笔试面试题，总结了一下，贴出来仅供参考，有错误的地方还请指出。

#### 1.Linux设置环境变量

暂时的：

    export MYNAME=”new name”

    echo $MYNAME

    new name

永久的：通过改变/etc/profile实现

    EG: export CLASSPATH=./java_HOME/lib;$JAVA_HOME/jre/lib

更改文件后执行

    source /etc/profile

#### 2.TCP连接的特点

(1)面向连接：采用C/S模型

(2)全双工

(3)安全可靠：

①流量控制：解决接收方不能不及时处理数据的问题

②拥塞控制：解决因网络通信延迟带来的数据丢失问题

③差错控制：解决数据被破坏、重复、时序和丢失的问题

(4)基于字节流

#### 3.为什么TCP连接需要三次握手，两次不可以吗?为什么?

两次不可以

三次握手连接过程

(1)建立连接时，客户端发送SYN(SYN=j)包到服务器，并进入SYN_SEND状态，等待服务器响应、、确认

(2)服务器收到SYN包，必须确认客户端的SYN(ACK=j+1)，同时自己也发送一个SYN包，即SYN+ACK包此时服务器进入SYN_RECV状态

(3)客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕客户端和服务器端进入ESTABLISHED状态，完成三次握手

为了保证服务端能收到客户端的信息并能做出正确的响应而进行前两次握手，为了保证客户端能够收到服务端的信息并能做出正确的响应而进行后两次响应

#### 4、代理的实现原理

代理服务器有很多种，大体分为三类：HTTP、FTP、SOCKS，其中又分为透明代理和不透明代理，透明代理一般是网关，为硬件

过程：

(1)客户端先和代理服务器通讯，建立TCP连接，目的IP是代理服务器的IP

(2)客户端发出GET命令，GET命令中包含URL或IP地址、明文

(3)代理服务器将其中的URL转换为IP地址，可能会有DNS，将源数据包中的数据拷贝下来，去掉URL，重新组包再发出去

(4)代理服务器和真实服务器通讯，源IP是代理服务器的IP

#### 5、TCP和UDP分别有什么优缺点

TCP：

优点：可靠、稳定

TCP的可靠体现在TCP在传输数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完之后，还会断开连接用来节约系统资源

缺点：慢，效率低，占用系统资源高，易被攻击

在传递数据之前要先建立连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞机制等都会消耗大量时间，而且要在每台设备上维护所有的传输连接。然而，每个链接都会占用系统的CPU、内存等硬件资源。因为TCP有确认机制、三次握手机制，这些也导致TCP容易被利用，实现DOS、DDOS、CC等攻击

UDP：

优点：快,比TCP稍安全

UDPm没有TCP拥有的各种机制，是一个无状态的传输协议，所以传递数据非常快，没有TCP的这些机制，被攻击利用的机制就少一些，但是也无法避免被攻击

缺点：不可靠，不稳定

因为没有TCP的那些机制，UDP在传输数据时，如果网络质量不好，就会很容易丢包，造成数据的缺失

适用场景：

TCP：当对网络通讯质量有要求时，比如HTTP、HTTPS、FTP等传输文件的协议， POP、SMTP等邮件传输的协议

UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景

#### 6、面向对象和面向过程的区别

面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就行。

面向对象是把构成问题事物分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。面向对象是以功能来划分问题，而不是步骤

#### 7、HTTP请求的过程与原理

HTTP是一种无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP遵循请求/应答模型

(1)建立TCP连接

(2)Web浏览器向Web服务器发送请求命令

(3)Web浏览器发送请求头信息

(4)Web服务器应答

(5)Web服务器发送应答头信息

(6)Web服务器向浏览器发送数据

(7)Web服务器关闭TCP连接

HTTP的长连接与短连接：

在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接，在服务端不保留连接的有关信息。

从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：

Connection:keep-alive

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件(如Apache)中设定这个时间。实现长连接要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

长连接短连接操作过程

短连接的操作步骤：

建立连接----数据传输-----关闭连接。。。建立连接-----数据传输----关闭连接

长连接的操作步骤：

建立连接---数据传输。。(保持连接)。。数据传输---关闭连接

长连接和短连接的优点和缺点

长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。但是会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损;如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某一个客户端连累后端服务。

短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。

HTTP报文格式：

请求消息格式：

* 请求行
* 头部行
* 附属行

响应消息格式：

* 状态行
* 头部行

#### 8、常见HTTP状态码

成功的状态码(基本以2开头)：这一类型的状态码，代表请求已成功被服务器接收、理解、并接受

200--请求已成功，请求所希望的响应头或数据体将随此响应返回

202--服务器已接受请求，但尚未处理

205--服务器成功处理了请求，且没有返回任何内容

内容被重定向(基本以3开头)：需要客户端采取进一步的操作才能完成请求

301--被请求的资源已永久移动到新位置

302--请求的资源临时从不同的 URI响应请求

303--对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源

305--被请求的资源必须通过指定的代理才能被访问

307--请求的资源临时从不同的URI 响应请求

请求失败的状态码(基本以4开头)：

400--语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求或者请求参数有误

401--当前请求需要用户验证

403--服务器已经理解请求，但是拒绝执行

404--请求的网页不存在

405--请求行中指定的请求方法不能被用于请求相应的资源

408--请求超时

服务器端的错误(基本以5开头)：了服务器在处理请求的过程中有错误或者异常状态发生

500--服务器内部错误

503--服务器暂时不可用

#### 9、什么是死锁

进程死锁，它是操作系统或系统软件运行的一种状态：在多任务系统下，当一个或多个进程等待系统资源，而资源又被进程本身或其他进程占用时，就形成了死锁

产生死锁的原因：

①系统资源不足

②进程运行推进的顺序不合适

③资源分配不当等

产生死锁的四个必要条件：

①互斥条件：一个资源每次只能被一个进程使用

②请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放

③不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺

④循环等待条件：若干进程之间形成一种头尾相连的循环等待资源关系

避免死锁的方法：

①有序的资源分配法

②银行家算法

解决死锁：

①进行系统的重新启动(最简单粗暴)

②撤销进程，剥夺资源

银行家算法

银行家算法是一种最有代表性的避免死锁的算法

我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。

#### 10、close_wait

在被动关闭连接的情况下，在已经接收到FIN，但是还没有发送自己FIN的时刻，连接处于close_wait状态。通常来讲，close_wait状态持续的时间应该很短，如SYN_RECV状态，但是在一些特殊情况下，就会出现连接长时间处于close_wait状态的情况。出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket连接，但是我方忙于读或者写。没有关闭连接，代码需要判断socket，一旦读到0，断开连接，read返回负，检查一下errno，如果不是AGAIN，就断开连接。

#### 11、time_wait

主动关闭的socket端会进入此状态，并且持续2MSL(最大分节生命期)时间长度，这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络消失。

作用：

a：可靠的实现TCP全双工连接的终止

b：允许老的重复分节在网络中消失

#### 12、进程间通信机制

管道、消息队列、共享内存(速度最快)、信号量、文件映射、匿名/命名管道


[1]: http://os.51cto.com/art/201709/551759.htm

