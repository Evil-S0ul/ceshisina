<font face=微软雅黑>

#### 建立索引的一些优化建议

比较重要的几个建议是： 多用like、不用null和where、索引字段上不用mysql函数。

1. 充分发挥like的作用

    如：select id from t where substring(name,1,3)='abc' ，name以abc开头的id**
    应改为:select id from t where name like 'abc%' 这样当name有索引的时候是可以用上索引的，如果改成like '%abc'能索引上么，答案是不能

1. 索引字段尽量不要设置为NULL并且进行值的where判断，否则将导致引擎放弃使用索引而进行全表扫描。尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值
1. 不要在索引字段上使用mysql的函数，如where substr(date,1,10) = '2016-09-07' 这样索引是会失效的，对于这种情况可以改写为 date between '2016-09-07 00:00:00' and '2016-09-07 23:59:59'
1. 复合索引建立以后如index_a_b_c建立在a、b、c3个字段上：

    * where a=XX and b=XX and c=XX能被索引
    * where a=XX能被索引
    * where a=XX and b=XX能被索引
    * where b=XX  不被索引
    * where c=XX不被索引
    * where b=XX and c=XX不被索引
    * where a=XX and c=XX索引较差
    * where b=XX and c=XX and a= XX不被索引
    * 你可以理解为当顺序不一样时，索引指向就变了。
    * 如果不是这种情况怎么办呢？还能怎么办，修改where顺序啊，总比不同的顺序再建个索引好

1. 在= 、group by 和 order by字段上面加上索引
1. 在join的时候中结果集更小的部分join更大的部门，这样可以减少缓存的开销
1. 索引并不是越多越好不要每一个字段建一个索引，即使这样mysql也会自身优化也只会选择其中的一个索引来执行，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。
1. 在使用in的时候可以尝试使用exists试试
1. 在join的时候减少extra字段中临时表的数量
1. 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。
1. 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。



</font>